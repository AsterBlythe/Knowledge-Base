# 1、知识点补充
#### ①mod 取余/取模 %
1、模同余:
a和b对c模同余的条件：
(a - b) % c == 0
2、加法取模的伪分配律：
(x + y) % z == (x % z + y % z) % z
3、乘法取模的伪分配律：
(x * y) % z == (x % z * y % z) % z

##### 取模可以边乘/加边取模

#### ② c++位运算符：
###### 1、位运算符基础：
位运算符作用于位，并逐位执行操作。

| 运算符 | 名称   | 描述             | 示例                    | 二进制结果    | 十进制结果 |
| --- | ---- | -------------- | --------------------- | -------- | ----- |
| &   | 按位与  | 两位都为 1 时结果为 1  | 5 & 3 (0101 & 0011)   | 0001     | 1     |
| \|  | 按位或  | 任一位为 1 时结果为 1  | 5 \| 3 (0101 \| 0011) | 0111     | 7     |
| ^   | 按位异或 | 两位不同时结果为 1     | 5 ^ 3 (0101 ^ 0011)   | 0110     | 6     |
| ~   | 按位取反 | 所有位取反（0→1，1→0） | ~5 (~0101)            | 11111010 | -6    |
| <<  | 左移   | 左移指定位数，低位补 0   | 5 << 2 (0101 << 2)    | 010100   | 20    |
| >>  | 右移   | 右移指定位数，高位补符号位  | 5 >> 1 (0101 >> 1)    | 0010     | 2     |
###### 2、异或的性质：
1、交换律
2、结合律（即 (a ^ b) ^ c == a ^ (b ^ c) ）
3、对于任何数，都有：x ^ x == 0, x ^ 0 == x
(与自己异或为0，与0异或为它本身)
4、自反性 A xor B xor B == A xor 0 == A
(用同样的运算因子(B)异或运算两次后仍得到A本身)

例子：
若有一个大小为n的数组，n为奇数，其中除了一个元素以外，每个元素两两成对相同（或者四四成对？），要找出这唯一一个没有成对的元素，只需要遍历数组，让所有元素异或一遍，由于结合律的存在，所有成对元素最终都会被异或成0，唯一不同的元素与0异或等于它本身，就找出来了这个元素。


#### ③ 快速幂
快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在O(log n)的时间内计算 $a^n$ 的小技巧，而暴力计算需要O(n)的时间。
可用于任何具有结合律的运算中，其中显然的是它可以应用于模意义下取幂、矩阵幂等运算。
二进制取幂的想法是：我们将取幂的任务按照指数的二进制表示来分割成更小的任务
###### 原理:
①迭代版本：
首先将n表示位2进制，如：
$$ 3^{13} = 3^{(\mathbf{1101})_2} = 3^8 \cdot 3^4 \cdot 3^1 $$
因为n有 |$\log_{2} n$| + 1个二进制位，因此当我们知道了 $a^1, a^2, a^4,\dots,a^{2|\log_{2}n|}$ 后，只用计算O($log n$)次乘法就可以算出 $a^n$ 。
于是我们只需要知道一个快速的方法来计算上述3的 $2^k$ 次幂的序列。(其中k = 1, 2, 4, 8, ...)
举例：
$$3^1 = 3$$
$$3^2 = (3^1)^2 = 3^2 = 9$$
$$3^4 = (3^2)^2 = 9^2 = 81$$
$$3^8 = (3^4)^2 = 81^2 = 6561$$
因此有
$$3^{13} = 3^8 \cdot 3^4 \cdot 3^1 = 6561 \cdot 81 \cdot 3 = 1594323$$
（省略复杂过程，意会一下把代码代入例子理解一下就可以了（其实是某人看的头大））


##### 快速幂模板：( typedef long long ll, LL; )
###### 1、递归版：
```c++
ll binpow_1(ll a, ll b) { //不好理解可以举例按代码流程推理
    if (b == 0) return 1;
    ll res = binpow_1(a, b / 2);
    if (b % 2)
        return res * res * a; //当形参b为奇数时，b一定等于（b/2）+（b/2）+1
    else
        return res * res; //当形参b为偶数时，b一定等于（b/2）+（b/2）
}
```
###### 2、非递归版： 与递归理论复杂度相同，实践过程中更快，因为递归会花费一定的开销
```c++
ll binpow_2(ll a, ll b) { //非递归式，与递归理论复杂度相同，实践过程中更快，因为递归会花费一定的开销
    ll res = 1;
    while(b > 0) {
        if(b & 1) res *= a; //b为奇数时就*a
        a *= a; //不管怎样都要除以2的所以a=a*a，下次b变成奇数时乘进res里
        b >>= 1; //等价于b/=2
    }
    return res;
}
```

# 2、题解
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll, LL;
#define pb push_back

//快速幂+取模的乘法伪分配律，保证运算速度+答案准确不超限
ll mod_pow(ll base, ll exponent, ll mod) { //每一步都取模，以防当数太大时超限
    ll result = 1;
    base %= mod; //取模
    while(exponent > 0) {
        if( exponent & 1) { //如果指数exponent是奇数
            result = (result * base) % mod; //取模
        }
        base = (base * base) % mod; //取模
        exponent >>= 1; //  /=2
    }
    return result; //返回边取模边算出来的幂
}

void solve() {
    ll p, g, a, b, num;
    cin >> p >> g >> a >> b >> num;
    ll A, B;
    // A = int(pow(g, a)) % p;
    // B = int(pow(g, b)) % p;
    ll K = mod_pow(g, a * b, p);
    ll C = K ^ num;
    cout << K << endl << C;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int t = 1;
    // cin << t;
    while(t--) {
        solve();
    }

    return 0;
}
```


