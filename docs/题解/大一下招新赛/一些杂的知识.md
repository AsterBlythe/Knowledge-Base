# 1、知识点补充
#### ①前缀和
定义：
前缀和可以简单理解为「数列的前n项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。
c++标准库中实现了前缀和函数`std::partial_sum`，定义与头文件`<numeric>`中

前缀和：快速计算区间的和
前缀运算：结合律、可逆运算，如乘法（可有取模处理，但好像恢复不了原数值）、异或
二维前缀：快速计算子矩阵和，容斥原理

前缀和：
```c++
vector<int> prefix(n);
for(int i = 0; i < n; i++) {
	if(i) prefix[i] = prefix[i - 1];
	prefix[i] += arr[i];
} // 从下标1开始遍历，每个都加上下标[i - 1]的数
```
c++中提供了系统库函数partial_sum可以直接代替上面这段代码：
```c++
#include<numeric>
partial_sum(arr.begin(), arr.end(), prefix.begin());
              // 起始        终止         目标位置
```
当查询区间[L, R]的总和时，只需要用R的前缀和减去L-1的前缀和：
```c++
vector<int> arr(n + 1), prefix(n + 1);
for(int i = 1; i <= n; i++) cin >> arr[i]; // i从1到n开始遍历
partial_sum(arr.begin(), arr.end(), prefix.begin());
// 声明并赋值R与L
int ans = prefix[R] - prefix[L - 1]; // 下标为0的vector值为0
```

接雨水：(用partial_sum()的方法)
```c++
int trap(vector<int> &h) {
	int n = h.size();
	vector<int> left(n), right(n);
	partial_sum(h.begin(), h.end(), left.begin(), range::max);
	partial_sum(h.begin(), h.rend(), right.rbegin(), ranges::max);
	int ans = 0;
	for(int i = 1; i < n - 1; i++) {
		ans += min(left[i], right[i] - h[i]);
	}
	return ans;
}
```

二维前缀和：（a是储存数据的数组）（之前vp用partial_sum有问题，用普通数组才过了题）
```c++
auto s = vector(n + 1, vector<int>(m + 1));
for(int i = 1; i <= n; i++) {
	partial_sum(a[i].begin(), a[i].end(), s[i].begin());
	for(int j = 1; j <= m; j++) {
		s[i][j] = s[i] [i] + s[i - 1][j];
	}
}
```
或者（注意数组标号有没有写对）
```c++
auto s = vector(n + 1, vector<int>(m + 1));
for(int i = 1; i <= n; i++) {
	for(int j = 1; j <= m; j++) {
	s[i][j] = a[i][j] + s[i - 1][j] + s[i] [j - 1] - s[i - 1][j - 1]};
}
```



#### ②代码操作次数的控制（时间复杂度）
![[9d0c4f3664ef5cad335df6ed5cb38a8.png]]
![[e2d6a60b7f77ef101e65890a1ec41ba.png]]
![[6ec120fd05fa22270bea70e32ffa147.png]]

#### ③gcd和lcm：
##### gcd：最大公约数（Greatest Common Divisor）
使用欧几里得算法可算出两个数的最大公约数（gcd）
在c++17中，我们有`<numeric>`头中的`std::gcd`与`std::lcm`来求最大公约数和最小公倍数
蓝桥杯比赛是c++11标准，需要自己编写gcd和lcm函数来使用
```c++ 递归求法
// version 1
int gcd(int a, int b) {
	if(b == 0) return a;
	returnn gcd(b, a % b);
}

// version 2
int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}
```
```c++ 迭代求法
int gcd(int a, int b) {
	while(b != 0) {
		int tmp = a;
		a = b;
		b = tmp % b;
	}
	return a;
}
```
##### lcm：最小公倍数（Least Common Multiple）
两个数的乘积除以他们的最大公因数就是他们的最小公倍数
```c++
ll gcd(ll a, ll b) {
	//只有b（第二个位置）在变化，所以只有b可能变为0
	return b == 0 ? a : gcd(b, a % b); //当b==0时返回最后的a值 
 } 

ll lcm(ll a, ll b)
{
	return a * b / gcd(a, b);
}
```
