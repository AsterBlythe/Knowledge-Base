# A. 纸牌游戏
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	ll a1, a2, b1, b2;
	int ans = 0;
	cin >> a1 >> a2 >> b1 >> b2;
	if(a1 > b1 && a2 >= b2 || a1 >= b1 && a2 > b2) ans+=2;
	if(a1 > b2 && a2 >= b1 || a1 >= b2 && a2 > b1) ans+=2;
	cout << ans;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
//	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# B.简单的问题
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	int n, x;
	cin >> n >> x;
	int a;
	ll sum = 0;
	for(int i = 0; i < n; i++) {
		cin >> a;
		sum += a;
	}
	if(double(sum)/n == x) cout << "YES" << endl;
	else cout << "NO" << endl;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# C.字符串之差
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	string s1, s2 = "codeforces";
	int ans = 0;
	cin >> s1;
	for(int i = 0; i < 10; i++) {
		if(s1[i] != s2[i]) ans++;
	}
	cout << ans << endl;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# D.出题人让你签你签不签,赶紧说
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	cout << "我活都得签";
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
//	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# E. SSVGG
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

vector<ll> zs;

void solve() {
	int k;
   cin >> k;
   cout << zs[k-1] << endl;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
    for(int i = 1; i < 1e5; i++) zs.pb(2*i*3-3);
    for(int i = 1; i < 1e5; i++) {
    	if((2*i*5-5)%3) zs.pb(2*i*5-5);
	}
	sort(zs.begin(), zs.end());
	
	int t = 1;
	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# F. 排列与合数
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	int a[5], p = -1, flag0=0;
	for(int i = 0; i < 5; i++) {
		scanf("%1d", &a[i]);
		if(a[i]%2==0) {
			p=i;
			if(a[i]==0) flag0=1;
		}
		
	}
	if(p==-1) cout << 97531 << endl;
	else {
		for(int i = 0; i < 5; i++){
			if(i!=p) cout << a[i];
		}\
		cout << a[p] << endl;
	}
}

int main() {
//	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# G. 望丽是大胃王
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

vector<ll> a;

int ans(ll m, int n) {
	int ans = -1, l = 0, mid;
	n--;
	while(l <= n) {
		mid = l + ((n-l)>>1);
		if(m >= a[mid]) {
			l = mid+1;
			ans = mid;
		}
		else {
			n = mid-1;
		}
	}
	return ans+1;
}

void solve() {
	int n, q;
	cin >> n >> q;
	int a1;
	for(int i = 0; i < n; i++) {
		cin >> a1;
		a.pb(a1);
	}
	sort(a.begin(), a.end());
	for(int i = 1; i < n; i++) {
		a[i] += a[i-1];
	}
	ll m;
	for(int i = 0; i < q; i++) {
		cin >> m;
		cout << ans(m, n) << endl;
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
//	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# H. 讨厌回文串
```c++
#include<bits/stdc++.h>
typedef long long ll, LL;
using namespace std;
#define pb push_back

void solve() {
	int n;
	cin >> n;
	int s[n];
	for(int i = 0; i < n; i++) {
		scanf("%1d", &s[i]);
	}
	if(n==2&&s[0]!=s[1]) cout << "YES" << endl;
	else cout << "NO" << endl;
}

int main() {
//	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
//	cin >> t;
    while(t--) {
    	solve();
	}
	
	return 0;
}
```

# I. 下雨了
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll, LL;
#define pb push_back;

void solve() {
    int n;
    cin >> n;
    ll a[n], ans[n] = {0}, result = 0;
    int max = 0;
    for(int i = 0; i < n; i++) {
        cin >> a[i];
        if(a[i] > max) max = a[i];
        else {
            ans[i] = max - a[i];
        }
    }
    max = 0;
    for(int i = n - 1; i >= 0; i--) {
        if(a[i] > max) max = a[i];
        else {
            result += min(max - a[i], ans[i]);
        }
    }
    cout << result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t = 1;
    // cin >> t;
    while(t--) {
        solve();
    }
    return 0;
}
// 从左开始往右，记录并不断更新最大数，当前位置低于最大位置则存放该位置雨水数量为 最大-当前
// 若不低于则记为0
// 从右往左再遍历，不断更新最大数，若不低于则记录0，若低于则记为 最大-当前
// 记录的雨水量取每个位置记录过的最小值
```

# J. cgy的鸡腿饼
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll, LL;
#define pb push_back

vector<int> dc;

void solve() {
    int n;
    cin >> n;
    // if(n == 1) cout << 0;
    // else {
        int a = dc[int(log2(n - 1))];
        for(int i = n - 1; i > 0; i--) {
            if(i > a) cout << i << ' ';
            else if(i == a) cout << a << ' ' << 0 << ' ';
            else cout << i << ' ';
        }
    // }
    

}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    dc.pb(1);
    for(int i = 0; i <= log2(3e5); i++) {
        dc.pb(dc[i] * 2);
    }

    int t = 1;
    // cin >> t;
    while(t--) {
        solve();
    }

    return 0;
}
// 0和任何数xor都是数本身
// 1   2   3   4   5    6    7    8    9    10   11   12   13  
// 1  10  11  100 101  110  111  1000 1001 1010 1011 1100 1101 
// 观察规律，分成2、 4、 8、 16等档次，
// 0与档次数放一起，最高档次数内放一起,靠边放，可保证最大xor结果一定为最高档次位
```